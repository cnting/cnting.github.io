---
layout:     post
title:      "使用Theme的正确方式"
subtitle:   " 记录 资源整理 以及 夜间模式适配 的过程"
date:       2020-12-23 17:24:00
author:     "cnting"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Android
    - Theme
---



前面一部分主要是摘录自[Flywith24 的 Android Styling系列文章](https://juejin.cn/post/6844903974047318030)（主要为了整理和理解方便😂），强烈建议大家看原文

## Theme 和 Style的区别

### Style是什么？

Style是**view的属性的集合** ，你可以将style视为`Map<view attribute,resource>`。这里的key是view的所有属性，都是可以在layout文件中配置的

一个style只能作用于其应用的view，不包含它的子view。

### Theme是什么？

Theme是资源的集合，它可以被style、layout或者其他引用。它为android资源提供语义明确的命名，如下：

```xml
<!-- Copyright 2019 Google LLC.	
   SPDX-License-Identifier: Apache-2.0 -->
<style name="Theme.Plaid" parent="…">
  <item name="colorPrimary">@color/teal_500</item>
  <item name="colorSecondary">@color/pink_200</item>
  <item name="android:windowBackground">@color/white</item>
</style>
```

Theme为这些已命名的资源提供正确的值，广泛应用在整个程序中。看下面的伪代码：

```java
/* Copyright 2019 Google LLC.	
   SPDX-License-Identifier: Apache-2.0 */
interface ColorPalette {
  @ColorInt val colorPrimary
  @ColorInt val colorSecondary
}

class MyView(colors: ColorPalette) {
  fab.backgroundTint = colors.colorPrimary
}

/* Copyright 2019 Google LLC.	
   SPDX-License-Identifier: Apache-2.0 */
val lightPalette = object : ColorPalette { … }
val darkPalette = object : ColorPalette { … }
//根据日夜间模式切换不同的theme，而不用更改view的逻辑
val view = MyView(if (isDarkTheme) darkPalette else lightPalette)
```

Theme可以在`application`、`Activity`、`View`中设置，也可以通过`ContextThemeWrapper`包装现有的Context来在代码中设置theme，然后将其用于inflate布局

TODO：需要添加例子

Theme可以作为Context的属性被获取，并且Theme可以被继承。



## 常用主题属性

常用的主题属性可以看这里：[Color Theming](https://material.io/develop/android/theming/color)

### Colors

* `?attr/colorPrimary` app 主色

* `?attr/colorSecondary` app 次级颜色，通常作为主色的补充

* `?attr/colorOn[Primary, Secondary, Surface etc]` 与命名颜色形成对比的颜色

* `?attr/color[Primary, Secondary]Variant` 给定颜色的阴影

* `?attr/colorSurface` 组件界面（卡片，表格，菜单等）的颜色

* `?android:attr/colorBackground` 背景

* `?attr/colorPrimarySurface` 在浅色主题的  `colorPrimary` 和深色主题的 `colorSurface` 间切换

* `?attr/colorError` 错误消息的颜色

* `?attr/colorControlNormal` 正常状态下图标/控件的颜色

* `?attr/colorControlActivated` 激活状态下图标/控件的颜色（例如 checked）

* `?attr/colorControlHighlight` 高亮颜色（例如 ripples， list selectors）

* `?android:attr/textColorPrimary` text 突出颜色

* `?android:attr/textColorSecondary` text 次要颜色

### Dimens

- `?attr/listPreferredItemHeight` list item 的标准（最小）高度
- `?attr/actionBarSize` toolbar 的高度

### Drawables

* `?attr/selectableItemBackground` 当前交互项的水波纹/高亮（也为前景提供了便利）

* `?attr/selectableItemBackgroundBorderless` 无界的水波纹

* `?attr/dividerVertical` 一个可绘制对象，可用作元素之间的垂直分隔线

* `?attr/dividerHorizontal` 一个可绘制对象，可用作元素之间的水平分隔线

### TextAppearances

放在`type.xml`文件中，定义[常用字体大小](https://material.io/design/typography/the-type-system.html#type-scale)，在TextView中可以使用如下方式引用

`````
android:textAppearance="?attr/textAppearanceBody1"
`````

* `?attr/textAppearanceHeadline1`  默认的浅色 96sp 文本

* `?attr/textAppearanceHeadline2`  默认的浅色 60sp 文本

* `?attr/textAppearanceHeadline3`  默认的普通 48sp 文本

* `?attr/textAppearanceHeadline4`  默认的普通 34sp 文本

* `?attr/textAppearanceHeadline5`  默认的普通 24sp 文本

* `?attr/textAppearanceHeadline6`  默认的中等 20sp 文本

* `?attr/textAppearanceSubtitle1`  默认的普通 16sp 文本

* `?attr/textAppearanceSubtitle2`  默认的中等 14sp 文本

* `?attr/textAppearanceBody1`  默认的普通 16sp 文本

* `?attr/textAppearanceBody2`  默认的普通 14sp 文本

* `?attr/textAppearanceCaption`  默认普通 12sp 文本

* `?attr/textAppearanceButton`  默认的中等全大写 14sp 文本

* `?attr/textAppearanceOverline`  默认的中等全大写 10sp 文本

### Shape

放在`shape.xml`文件中，定义一些常用形状的圆角等属性，具体使用方式可以看这里：[Shape Theming](https://material.io/develop/android/theming/shape)。要在自定义组件上设置shape，可能需要使用`MaterialShapeDrawable`，它可以理解并实现shape

* `?attr/shapeAppearanceSmallComponent` 在 Button ，Chip，Text 的属性中使用，默认 4dp 的圆角

* `?attr/shapeAppearanceMediumComponent` 在 Card，Dialog，Date Picker 中使用，默认 4dp 的圆角

* `?attr/shapeAppearanceLargeComponent` 在 Bottom Sheet 中使用，默认 0dp 圆角

### Button Styles

<img src="https://lh3.googleusercontent.com/paigCrPwj4o5nOy781U_k0QfrtmDz9dcQEdBzUUqitMEfzXhy4XWKwQPEFiM0qbpZidJxv3VE3FlFK-GkcHVLRXm8ew0GBn9HjRw8Ec=w1064-v0" alt="&quot;Button types - text, outlined, contained and toggle.&quot;" style="zoom:50%;" />

Material 定义了四种类型的Button：Text、Outlined、Contained、Toggle，可用于设置`MaterialButton`的 style，具体使用看这里：[Buttons](https://material.io/components/buttons/android)

* `?attr/materialButtonStyle` 默认样式，可省略

* `?attr/borderlessButtonStyle` 文本样式的 button

* `?attr/materialButtonOutlinedStyle` outline 样式的 button

* `?attr/materialButtonToggleGroupStyle` Toggle样式的button。Toggle类型按钮使用`MaterialButtonToggleGroup`，示例如下：

  ```xml
  <com.google.android.material.button.MaterialButtonToggleGroup
      android:id="@+id/toggleButton"
      android:layout_width="wrap_content"
      android:layout_height="wrap_content">
      <Button
          android:id="@+id/button1"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:text="Button 1"
          style="?attr/materialButtonOutlinedStyle"
      />
      <Button
          android:id="@+id/button2"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:text="Button 2"
          style="?attr/materialButtonOutlinedStyle"
      />
      <Button
          android:id="@+id/button3"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:text="Button 3"
          style="?attr/materialButtonOutlinedStyle"
      />
  </com.google.android.material.button.MaterialButtonToggleGroup>
  ```

### App vs Android namespace

你可能注意到，有些属性由 `?android:attr/foo` 引用，而其他的则为 `?attr/bar` 。这是因为它们中的部分是由 Android Platform 定义的，因此您需要 `android`前缀通过命名空间引用它们（就像 layout 中 view 的属性：`android:id`）。那些不是来自静态库（即 AppCompat 或 MDC ），它们已编译到您的应用程序中，因此不需要名称空间（类似于您在布局中使用 `app：baz` 的方式）。一些元素在 platform 和 library 均有定义（例如 `colorPrimary`）。**在这种情况下，最好使用非平台版本，这样可以在所有 API 级别上使用**。例如它们是在 library 中重复定义恰好目的是为了向后兼容

可用属性的完整列表：

* [Android platform](https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/attrs.xml)
* [AppCompat](https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/appcompat/appcompat/src/main/res/values/attrs.xml)
* [Material Color](https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/color/res/values/attrs.xml)
* [Material Shape](https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/shape/res/values/attrs.xml)
* [Material Type](https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/typography/res/values/attrs.xml)



## Theme overlays



## 实例1

一直以来，使用color、theme都是按照下面方式

在`res/values/colors.xml` 和 `res/values-night/colors.xml` 中定义`color_primary`，然后在layout中使用`@color/color_primary`。

这样有几个不好的点：

1. color里的命名既代表了语义又代表了色值，会导致一些色值重复定义
2. 某些情况下，有的颜色不想跟着日夜间模式切换而改变，就需要再重复定义一些相同的颜色了



正确做法应该是这样：

1. 在color中用颜色值命名，比如`brand_green`、`brand_orange`。（这样应该只需要一个colors.xml了吧？）
2. 在theme中定义`<item name="colorPrimary">@color/brand_green</item>`
3. 在layout中引用`android:background="?attr/colorPrimary"`





## 常见问题

### 1. ActionBar和ToolBar区别

ActionBar是3.0推出的，ToolBar是5.0推出的，目的是为了取代ActionBar。取代方式如下：

1. 在主题theme里继承后缀为`.NoActionBar` 的主题
2. 在代码中设置 `setSupportActionBar(toobar)`



### 2.低版本使用alpha

alpha组件是在API23后引入，所以如果min sdk比这个低，要使用兼容的[AppCompatResources.getColorStateList](https://developer.android.com/reference/androidx/appcompat/content/res/AppCompatResources.html#public-methods_1) 并一直使用 `android:alpha` 命名空间，不要使用 `app:alpha` 命名空间

### 3. 检测工具

[Making Android Lint Theme Aware — Part 1](https://proandroiddev.com/making-android-lint-theme-aware-6285737b13bc)

