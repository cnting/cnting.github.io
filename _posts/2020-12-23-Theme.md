---
layout:     post
title:      "使用Theme的正确方式"
subtitle:   " 记录 资源整理 以及 夜间模式适配 的过程"
date:       2020-12-23 17:24:00
author:     "cnting"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Android
    - Theme
---



前面一部分主要是摘录自[Flywith24 的 Android Styling系列文章](https://juejin.cn/post/6844903974047318030)（主要为了整理和理解方便😂），强烈建议大家看原文



## 一、Theme 和 Style的区别

#### Style是什么？

Style是**view的属性的集合** ，你可以将style视为`Map<view attribute,resource>`。这里的key是view的所有属性，都是可以在layout文件中配置的

一个style只能作用于其应用的view，不包含它的子view。使用时用`style`标签

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85e7217bbc0f46c591d574cf85828b70~tplv-k3u1fbpfcp-zoom-1.image" alt="Style 作用范围" style="zoom:55%;" />



#### Theme是什么？

Theme是资源的集合，它可以被style、layout或者其他引用。它为android资源提供语义明确的命名，如下：

```xml
<!-- Copyright 2019 Google LLC.	
   SPDX-License-Identifier: Apache-2.0 -->
<style name="Theme.Plaid" parent="…">
  <item name="colorPrimary">@color/teal_500</item>
  <item name="colorSecondary">@color/pink_200</item>
  <item name="android:windowBackground">@color/white</item>
</style>
```

Theme为这些已命名的资源提供正确的值，广泛应用在整个程序中。在引用主题属性时，可以使用`?attr/`语法，其中`?`代表在当前主题中搜索。

Theme可以在`application`、`Activity`、`View`中设置，可以作为Context的属性被获取，也可以通过`ContextThemeWrapper`包装现有的Context来在代码中设置theme，然后将其用于inflate布局，具体使用方法看第三节

定义的theme会生成一个树，在此树的任何级别上指定主题都会影响到后代节点。使用时用`theme`标签

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6f53dd8ede247e6a027d8601961b966~tplv-k3u1fbpfcp-zoom-1.image" alt="theme 作用范围" style="zoom:55%;" />



总结下：

|       | 概念           | 作用范围                           |
| ----- | -------------- | ---------------------------------- |
| Style | view的属性集合 | 只作用于应用的view，没有继承关系   |
| Theme | 资源的集合     | 会作用于树中所有子节点，有继承关系 |



## 二、常用主题属性

系统定义了一些常用的主题属性，我们可以借鉴下，看这里：[Color Theming](https://material.io/develop/android/theming/color)

#### Colors

* `?attr/colorPrimary` app 主色
* `?attr/colorSecondary` app 次级颜色，通常作为主色的补充
* `?attr/colorOn[Primary, Secondary, Surface etc]` 与命名颜色形成对比的颜色，常用来定义文字颜色
* `?attr/color[Primary, Secondary]Variant` 给定颜色的阴影
* `?attr/colorSurface` 组件界面（卡片，表格，菜单等）的颜色
* `?android:attr/colorBackground` 背景
* `?attr/colorPrimarySurface` 在浅色主题的  `colorPrimary` 和深色主题的 `colorSurface` 间切换
* `?attr/colorError` 错误消息的颜色
* `?attr/colorControlNormal` 正常状态下图标/控件的颜色
* `?attr/colorControlActivated` 激活状态下图标/控件的颜色（例如 checked）
* `?attr/colorControlHighlight` 高亮颜色（例如 ripples， list selectors）
* `?android:attr/textColorPrimary` text 突出颜色
* `?android:attr/textColorSecondary` text 次要颜色

#### Dimens

- `?attr/listPreferredItemHeight` list item 的标准（最小）高度
- `?attr/actionBarSize` toolbar 的高度

#### Drawables

* `?attr/selectableItemBackground` 当前交互项的水波纹/高亮（也为前景提供了便利）

* `?attr/selectableItemBackgroundBorderless` 无界的水波纹

* `?attr/dividerVertical` 一个可绘制对象，可用作元素之间的垂直分隔线

* `?attr/dividerHorizontal` 一个可绘制对象，可用作元素之间的水平分隔线

#### TextAppearances

放在`type.xml`文件中，定义[常用字体大小](https://material.io/design/typography/the-type-system.html#type-scale)，在TextView中可以使用如下方式引用

`````
android:textAppearance="?attr/textAppearanceBody1"
`````

* `?attr/textAppearanceHeadline1`  默认的浅色 96sp 文本

* `?attr/textAppearanceHeadline2`  默认的浅色 60sp 文本

* `?attr/textAppearanceHeadline3`  默认的普通 48sp 文本

* `?attr/textAppearanceHeadline4`  默认的普通 34sp 文本

* `?attr/textAppearanceHeadline5`  默认的普通 24sp 文本

* `?attr/textAppearanceHeadline6`  默认的中等 20sp 文本

* `?attr/textAppearanceSubtitle1`  默认的普通 16sp 文本

* `?attr/textAppearanceSubtitle2`  默认的中等 14sp 文本

* `?attr/textAppearanceBody1`  默认的普通 16sp 文本，默认字样式

* `?attr/textAppearanceBody2`  默认的普通 14sp 文本

* `?attr/textAppearanceCaption`  默认普通 12sp 文本

* `?attr/textAppearanceButton`  默认的中等全大写 14sp 文本

* `?attr/textAppearanceOverline`  默认的中等全大写 10sp 文本

#### Shape

放在`shape.xml`文件中，定义一些常用形状的圆角等属性，具体使用方式可以看这里：[Shape Theming](https://material.io/develop/android/theming/shape)。要在自定义组件上设置shape，可能需要使用`MaterialShapeDrawable`，它可以理解并实现shape

* `?attr/shapeAppearanceSmallComponent` 在 Button ，Chip，Text 的属性中使用，默认 4dp 的圆角

* `?attr/shapeAppearanceMediumComponent` 在 Card，Dialog，Date Picker 中使用，默认 4dp 的圆角

* `?attr/shapeAppearanceLargeComponent` 在 Bottom Sheet 中使用，默认 0dp 圆角

#### Button Styles

<img src="https://lh3.googleusercontent.com/paigCrPwj4o5nOy781U_k0QfrtmDz9dcQEdBzUUqitMEfzXhy4XWKwQPEFiM0qbpZidJxv3VE3FlFK-GkcHVLRXm8ew0GBn9HjRw8Ec=w1064-v0" alt="&quot;Button types - text, outlined, contained and toggle.&quot;" style="zoom:50%;" />

Material 定义了四种类型的Button：Text、Outlined、Contained、Toggle，可用于设置`MaterialButton`的 style，具体使用看这里：[Buttons](https://material.io/components/buttons/android)

* `?attr/materialButtonStyle` 默认样式，可省略

* `?attr/borderlessButtonStyle` 文本样式的 button

* `?attr/materialButtonOutlinedStyle` outline 样式的 button

* `?attr/materialButtonToggleGroupStyle` Toggle样式的button。Toggle类型按钮使用`MaterialButtonToggleGroup`，示例如下：

  ```xml
  <com.google.android.material.button.MaterialButtonToggleGroup
      android:id="@+id/toggleButton"
      android:layout_width="wrap_content"
      android:layout_height="wrap_content">
      <Button
          android:id="@+id/button1"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:text="Button 1"
          style="?attr/materialButtonOutlinedStyle"
      />
      <Button
          android:id="@+id/button2"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:text="Button 2"
          style="?attr/materialButtonOutlinedStyle"
      />
      <Button
          android:id="@+id/button3"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:text="Button 3"
          style="?attr/materialButtonOutlinedStyle"
      />
  </com.google.android.material.button.MaterialButtonToggleGroup>
  ```

#### App vs Android namespace

你可能注意到，有些属性value由 `?android:attr/foo` 引用，而其他的则为 `?attr/bar` 。这是因为它们中的部分是由 Android Platform 定义的，因此您需要 `android`前缀通过命名空间引用它们（就像 layout 中 view 的属性：`android:id`）。那些不是来自静态库（即 AppCompat 或 MDC ），它们已编译到您的应用程序中，因此不需要名称空间（类似于您在布局中使用 `app：baz` 的方式）。一些元素在 platform 和 library 均有定义（例如 `colorPrimary`）。**在这种情况下，最好使用非平台版本`?attr/bar`，这样可以在所有 API 级别上使用**。例如它们是在 library 中重复定义恰好目的是为了向后兼容

同时，由于部分属性key的版本兼容问题，为了避免添加多个版本的styles文件，可以省略`android:`命名空间

可用属性的完整列表：

* [Android platform](https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/attrs.xml)
* [AppCompat](https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/appcompat/appcompat/src/main/res/values/attrs.xml)
* [Material Color](https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/color/res/values/attrs.xml)
* [Material Shape](https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/shape/res/values/attrs.xml)
* [Material Type](https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/typography/res/values/attrs.xml)





## 三、ThemeOverlay

Theme主要分两种：

* 给整个页面设置的theme，一般设置在Activity上，系统定义的这类theme一般命名的前缀是AppCompat，例如`Theme.AppCompat.DayNight.DarkActionBar`
* 给 **view** 设置的theme，区别于整个页面的theme，这时候应该使用ThemeOverlay。系统定义的这类theme一般命名前缀是ThemeOverlay，例如`ThemeOverlay.MaterialComponents.Toolbar.Surface`

ThemeOverlay只定义想要改变的属性，其他属性不会被改变，**注意parent经常会设置为""**。看下面这个例子，只有`colorControlNormal`和actionMenuTextColor属性改变

![image-20201224104052296](https://gitee.com/cnting/cnting-blog-img/raw/master/img/image-20201224104052296.png)

系统定义了很多常用的ThemeOverlay，可以看看[MDC](https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/theme/res/values/themes_overlay.xml) 和 [AppCompat](https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/appcompat/appcompat/src/main/res/values/themes.xml#76)

这里需要注意一点，**当在view中使用Theme时，应该使用ThemeOverlay**

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b430a9dde81f4372921e81ed2f9db63a~tplv-k3u1fbpfcp-zoom-1.image)

#### 内存开销

每声明一个`android:theme`,都会创建一个新的`ContextThemeWrapper`来分配新的Theme和Resource实例，还间接引入更多层的styling，所以要谨慎使用theme，尤其在RecyclerView下



#### 使用正确的Context

Theme可以作为Context的属性被获取，并且它可以从任何Context或者Context的子类获得，例如Activity、View、ViewGroup。这些对象存在于一个树中，在此树的任何级别上指定主题都会影响到后代节点。

查找theme是跟当前Context相关的，所以要使用跟当前层级最接近的Context，例如下面这个例子，`Theme.App.Foo`和`Theme.App.Bar`中都定义了`foo`属性

```xml
<ViewGroup …
  android:theme="@style/Theme.App.Foo">
  <Button …
    android:theme="@style/Theme.App.Bar"/>
</ViewGroup>
```

如果我想在代码中查找`Button `的`foo`的值，需要使用`button.getContext()`

```java
button.background = AppCompatResources.getDrawable(button.context,R.drawable.foo)
```

上面说到Theme可以作为Context的属性被获取，但这个Context不包含Application。Application Context不包含任何主题信息，在manifest中`<application>`标签中设置的主题仅作用于那些没指定主题的Activity。因此不要使用Application Context加载theme中的资源。

这也说明了在Activity定义的theme不会受Application中的Theme影响



#### 在代码中使用Theme Overlay

如果想要在代码中使用Theme Overlay，可以将其包裹成`ContextThemeWrapper`，这也是`android:theme`标签内部做的事情

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95f6cda77a05443eae87ba7e2b93f3e3~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:67%;" />



## 一些小技巧

#### 1. 设置透明度

使用`ColorStateList`(也就是常说的Selector)，只配置一个item，并设置透明度

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c626bcd9fedf4ee9ae4b8aa09bc732f9~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:87%;" />



#### 2. ColorStateList 和 Drawable转换

给view设置background等属性时可以直接传入color，在内部系统会将它包装成`ColorDrawable`。但如果将`ColorStateList`传入就不行，在API 28之前会报错。这是因为`ColorDrawable`是无状态的，在Android 10中，官方加入了`ColorStateListDrawable`解决这个问题，但为了所有API都能用，我们可以使用`backgroundTint`方式解决

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8eb34265ef6438c847a147e6350dc8a~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:80%;" />



#### 3. 拆分多个文件

* `theme.xml` : Theme 和 Theme Overlay
* `type.xml`： 字体、文本外观、文本尺寸、字体文件等
* `style.xml`：只有widget style
* `shape.xml`：形状相关的style
* `dimens.xml`、`colors.xml`、`strings.xml`



#### 4. 命名规范

```
[Style Type].[Group Name].[Sub-group Name].[Variant Name]
```

###### 1. Style Type

描述这个style类型，可以是theme、样式、文本外观、Theme Overlay等

| 类型          | 常用名字        | 举例                                                  |
| ------------- | --------------- | ----------------------------------------------------- |
| theme         | Theme           | **Theme**.AppCompat.DayNight.DarkActionBar            |
| Theme Overlay | ThemeOverlay    | **ThemeOverlay**.MaterialComponents.Toolbar.Surface   |
| 控件 style    | Widget          | **Widget**.AppCompat.Toolbar                          |
| 文本样式      | TextAppearance  | **TextAppearance**.AppCompat.Body1                    |
| 形状          | ShapeAppearance | **ShapeAppearance**.MaterialComponents.LargeComponent |
| 动画          | Animation       | **Animation**.Design.BottomSheetDialog                |

###### 2. Group Name

通常采用应用名称，如果是多module也可以用module名

###### 3. Sub-group name

通常用于widget，例如：Widget.Design.**TabLayout**

###### 4. Variant Name

这是可选的，这是主题的变量，例如：

* ThemeOverlay.MaterialComponents.Toolbar.**Primary**
* ThemeOverlay.MaterialComponents.Toolbar.**Surface**



###### 5. ColorPrimary的使用

有些时候，希望某个颜色日间模式使用colorPrimary，夜间模式使用colorSurface，可以使用系统提供的`?attr/colorPrimarySurface`



## 实例1

一直以来，使用color、theme都是按照下面方式

在`res/values/colors.xml` 和 `res/values-night/colors.xml` 中定义`color_primary`，然后在layout中使用`@color/color_primary`。

这样有几个不好的点：

1. color里的命名既代表了语义又代表了色值，会导致一些色值重复定义
2. 某些情况下，有的颜色不想跟着日夜间模式切换而改变，就需要再重复定义一些相同的颜色了



正确做法应该是这样：

1. 在color中用颜色值命名

   ```xml
   //values/colors.xml
   <color name="indigo_500">...</color>
   <color name="indigo_200">...</color>
   ```

   

2. 在theme抽取公共部分到`Base.Theme.MyApp`，然后再根据日夜间模式定义两个theme中定义

   ```xml
   //values/themes.xml
   <style name="Theme.MyApp" parent="Base.Theme.MyApp">
     <item name="colorPrimary">@color/indigo_500</item>
   </style>
   
   //values-night/themes.xml
   <style name="Theme.MyApp" parent="Base.Theme.MyApp">
     <item name="colorPrimary">@color/indigo_200</item>
   </style>
   ```

   

3. 在layout中引用`android:background="?attr/colorPrimary"`





## 常见问题

#### 1. ActionBar和ToolBar区别

ActionBar是3.0推出的，ToolBar是5.0推出的，目的是为了取代ActionBar。取代方式如下：

1. 在主题theme里继承后缀为`.NoActionBar` 的主题

2. 在代码中设置 `setSupportActionBar(toobar)`

   

#### 2.低版本使用alpha

alpha组件是在API23后引入，所以如果min sdk比这个低，要使用兼容的[AppCompatResources.getColorStateList](https://developer.android.com/reference/androidx/appcompat/content/res/AppCompatResources.html#public-methods_1) 并一直使用 `android:alpha` 命名空间，不要使用 `app:alpha` 命名空间

#### 3. 检测工具

[Making Android Lint Theme Aware — Part 1](https://proandroiddev.com/making-android-lint-theme-aware-6285737b13bc)

